# 3장 - 16. 임시 필드

임시 필드는 특정 상황에서만 값이 설정되는 필드입니다.

코드가 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵습니다. 사용자는 쓰이지 않는 것처럼 보이는 필드가 존재하는 이유를 파악해야하기 때문입니다.

이러한 필드를 발견하면

1. **클래스 추출하기(7.5)** 를 통해 위치를 찾아주거나
2. **함수 옮기기(8.1)** 를 통해 임시 필드들과 관련된 코드를 모두 새 클래스에 넣거나
3. 임시 필드가 유효한지 확인한 후 동작하는 조건부 로직이 있다면 **특이 케이스 추가하기(10.5)** 로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거할 수 있습니다.

특이 케이스 추가하기 방법을 자세히 살펴보도록 하겠습니다.

예를 들어 전력 회사가 전력이 필요한 현장에 인프라를 설치해 서비스를 제공하는 코드가 있습니다.

```jsx
class Site {
	get customer() {
		return this._customer
	}
}

class Customer {
	get name()
	get billingPlan()
}
```

누군가 이사를 가고 이사를 왔을 수 있기 때문에 미확인 고객이 존재한다고 가정해봅니다.

미확인 고객을 처리해야 하는 케이스가 여러 곳에 있고 유사한 방식으로 처리된 것을 확인할 수 있습니다.

```jsx
// 케이스 1
const aCustomer = site.customer;

let customerName;
if (aCustomer === "미확인 고객") customerName = "거주자";
else customerName = aCustomer.name;

// 케이스 2
if (aCustomer !== "미확인 고객") aCustomer.billingPlan = newPlan;
```

특이 케이스 객체를 도입하기 위해 미확인 고객인지 나타내는 메서드를 고객 클래스에 추가합니다.

```jsx
class Customer {
	get name()
	get billingPlan()
	get isUnknown() {
		return false
	}
}
```

그 다음 미확인 고객 전용 클래스를 만듭니다.

```jsx
class UnknownCustomer {
  get isUnknown() {
    return true;
  }
}
```

특이 케이스일 때 UnknownCustomer를 반환해줄 수 있도록 Site 클래스를 수정해줍니다.

```jsx
class Site {
  get customer() {
    return this._customer === "미확인 고객"
      ? new UnknownCustomer()
      : this._customer;
  }
}
```

그리고 미확인 고객인지 확인하는 함수를 만듭니다.

```jsx
function isUnknown(arg) {
  if (!(arg instanceof Customer || arg instanceof UnknownCustomer)) {
    throw new Error("잘못된 타입");
  }
  return arg.isUnknown;
}
```

최종적으로 수정된 코드는 아래와 같습니다.

```jsx
class Customer {
  get name() {
    return this._name;
  }
  get billingPlan() {
    return this._billingPlan;
  }
  get isUnknown() {
    return false;
  }
}

// 특이 케이스 클래스
class UnknownCustomer {
  get name() {
    return "거주자";
  }
  get billingPlan() {
    return "기본 요금제";
  }
  get isUnknown() {
    return true;
  }
}

const unknownCustomer = new UnknownCustomer();

class Site {
  get customer() {
    return this._customer === "미확인 고객" ? unknownCustomer : this._customer;
  }
}

function isUnknown(arg) {
  if (!(arg instanceof Customer || arg instanceof UnknownCustomer)) {
    throw new Error("잘못된 타입");
  }
  return arg.isUnknown;
}
```

```jsx
const site = new Site();
site._customer = "미확인 고객";

const aCustomer = site.customer;

console.log(aCustomer.name); // "거주자"
console.log(aCustomer.billingPlan); // "기본 요금제"
console.log(aCustomer.isUnknown); // true
```

⇒ 이처럼 특정 값에 대해 똑같이 반응하는 코드가 여러 곳에 흩어져 있다면, 그 반응들을 특이 케이스 객체로 모아두는 것이 효율적입니다. 이렇게 하면 조건문이 사라지고, 코드가 읽기 쉽고 변경에 강해지기 때문입니다.
