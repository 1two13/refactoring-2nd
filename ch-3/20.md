# 3장 - 20. 거대한 클래스

한 클래스가 너무 많은 일을 하려다 보면 필드 수가 계속 늘어나고, 클래스에 필드가 너무 많으면 중복 코드가 생깁니다.

이럴 때는 개별 클래스로 추출하는 것이 좋은데, 사용하는 방법으로 3가지가 있습니다.

1. 클래스 추출하기(7.5)

   클래스 추출하기로 필드들 일부를 따로 묶습니다. 같은 컴포넌트에 모아두기 좋은 필드들을 선택하면 됩니다. 일반적으로는, 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보입니다.

반면, 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 것이 좋다면 아래 2가지 방법을 사용하면 됩니다.

1. 슈퍼클래스 추출하기(12.8)
2. 타입 코드를 서브클래스로 바꾸기(12.6)

### 1. 클래스 추출하기

특정 데이터나 메서드를 제거해도 다른 필드나 메서드들이 논리적으로 문제가 없다면 분리할 수 있다는 뜻이다!그리고 작은 일부 기능만을 위해 서브 클래스를 만들거나, 확장해야 할 기능이 무엇이냐에 따라 서브클래스를 만드는 방식도 달라진다면 클래스를 나눠야 한다는 신호입니다.

예를 들어 아래 Customer라는 클래스는 고객 정보와 주소 정보를 동시에 관리하고 있습니다.

**리팩터링 전**

```jsx
class Customer {
  constructor(name, street, city, zip) {
    this.name = name;
    this.street = street;
    this.city = city;
    this.zip = zip;
  }

  getFullName() {
    return this.name;
  }

  getFullAddress() {
    return `${this.street}, ${this.city}, ${this.zip}`;
  }

  updateAddress(street, city, zip) {
    this.street = street;
    this.city = city;
    this.zip = zip;
  }
}
```

**리팩터링 후**

```jsx
// 주소 관련 데이터를 따로 Address 클래스로 추출
class Address {
  constructor(street, city, zip) {
    this.street = street;
    this.city = city;
    this.zip = zip;
  }

  getFullAddress() {
    return `${this.street}, ${this.city}, ${this.zip}`;
  }

  update(street, city, zip) {
    this.street = street;
    this.city = city;
    this.zip = zip;
  }
}

// 고객 클래스는 주소 객체를 포함만 함
class Customer {
  constructor(name, address) {
    this.name = name;
    this.address = address;
  }

  getFullName() {
    return this.name;
  }

  getFullAddress() {
    return this.address.getFullAddress();
  }
}
```

주소 관련 데이터를 따로 Address 클래스로 추출하고 Customer 클래스는 주소 객체를 포함만 하는 방식으로 리팩터링했습니다.

그럼 코드의 응집도를 높이고, 독립적으로 재사용할 수 있는 구조를 만들 수 있게 됩니다.

### 2. 슈퍼클래스 추출하기

두 개 이상의 클래스가 비슷한 필드 또는 메서드를 가지고 있을 때 공통 부분을 슈퍼클래스로 빼낼 수 있습니다.

**리팩터링 전**

- Employee와 Student 클래스 모두 name 필드와 getName 메서드를 중복해서 가지고 있습니다.
- 또한 describe() 구조도 유사합니다.

```jsx
class Employee {
  constructor(name, salary) {
    this.name = name;
    this.salary = salary;
  }

  getName() {
    return this.name;
  }

  getSalary() {
    return this.salary;
  }

  describe() {
    return `${this.name} (직원) - 연봉: ${this.salary}`;
  }
}

class Student {
  constructor(name, grade) {
    this.name = name;
    this.grade = grade;
  }

  getName() {
    return this.name;
  }

  getGrade() {
    return this.grade;
  }

  describe() {
    return `${this.name} (학생) - 학년: ${this.grade}`;
  }
}
```

**리팩터링 후**

- Person이라는 슈퍼클래스를 생성하고, 해당 class에서 name 필드와 getName() 메서드를 호출합니다.

```jsx
// 공통 슈퍼클래스
class Person {
  constructor(name) {
    this.name = name;
  }

  getName() {
    return this.name;
  }

  // 서브클래스에서 세부 정보를 구현하도록 강제
  describe() {
    throw new Error("서브클래스에서 구현해야 합니다.");
  }
}

class Employee extends Person {
  constructor(name, salary) {
    super(name);
    this.salary = salary;
  }

  getSalary() {
    return this.salary;
  }

  describe() {
    return `${this.name} (직원) - 연봉: ${this.salary}`;
  }
}

class Student extends Person {
  constructor(name, grade) {
    super(name);
    this.grade = grade;
  }

  getGrade() {
    return this.grade;
  }

  describe() {
    return `${this.name} (학생) - 학년: ${this.grade}`;
  }
}
```

### 3. 타입 코드를 서브클래스로 바꾸기

비슷한 대상들을 특정 특성에 따라 구분해야 할 때 타입 코드 필드를 사용합니다.

타입 코드는 열거형, 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 많습니다.

타입 코드를 서브클래스로 바꾸는 리팩터링은 대상 클래스에 직접 적용할수도, 타입 코드 자체에 적용할 수도 있습니다.

**리팩터링 전**

- 새로운 타입이 추가될 때마다 Employee 클래스가 계속 수정되어야 하고,
- switch문 또는 if문이 계속 늘어납니다.

```jsx
class Employee {
  constructor(name, type) {
    this.name = name;
    this.type = type; // "engineer" | "manager" | "sales"
  }

  getDescription() {
    switch (this.type) {
      case "engineer":
        return `${this.name} (엔지니어)`;
      case "manager":
        return `${this.name} (매니저)`;
      case "sales":
        return `${this.name} (영업)`;
      default:
        return this.name;
    }
  }
}
```

**리팩터링 후(대상 클래스에 직접 적용)**

- 대상 클래스에 있는 타입 코드를 제거하고 클래스 자체가 타입을 표현할 수 있도록 수정했습니다.

```jsx
class Employee {
  constructor(name) {
    this.name = name;
  }

  getDescription() {
    throw new Error("서브클래스에서 구현해야 합니다.");
  }
}

class Engineer extends Employee {
  getDescription() {
    return `${this.name} (엔지니어)`;
  }
}

class Manager extends Employee {
  getDescription() {
    return `${this.name} (매니저)`;
  }
}

class Sales extends Employee {
  getDescription() {
    return `${this.name} (영업)`;
  }
}
```

**리팩터링 후(타입 코드 자체에 적용)**

- 외부 서비스를 통해 타입 코드가 들어오는 경우, 타입 코드 자체를 서브 클래스 메서드로 매핑합니다.

```jsx
class Employee {
  constructor(name) {
    this.name = name;
  }

  getDescription() {
    throw new Error("서브클래스에서 구현해야 합니다.");
  }

  // 타입 코드 → 서브클래스 메서드
  static create(name, typeCode) {
    switch (typeCode) {
      case "engineer":
        return new Engineer(name);
      case "manager":
        return new Manager(name);
      case "sales":
        return new Sales(name);
      default:
        throw new Error(`알 수 없는 타입 코드: ${typeCode}`);
    }
  }
}

class Engineer extends Employee {
  getDescription() {
    return `${this.name} (엔지니어)`;
  }
}

class Manager extends Employee {
  getDescription() {
    return `${this.name} (매니저)`;
  }
}

class Sales extends Employee {
  getDescription() {
    return `${this.name} (영업)`;
  }
}

// 외부 API에서 받은 타입 코드 활용
const dataFromAPI = [
  { name: "홍길동", type: "engineer" },
  { name: "김철수", type: "manager" },
];

const employees = dataFromAPI.map((d) => Employee.create(d.name, d.type));

employees.forEach((e) => console.log(e.getDescription()));
// 홍길동 (엔지니어)
// 김철수 (매니저)
```
