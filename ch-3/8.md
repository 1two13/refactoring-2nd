# 3장 - 8. 산탄총 수술

산탄총 수술은 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 필요합니다.

이럴 때 사용하는 기법은 크게 7가지입니다.

함께 변경되는 대상들을 한 모듈로 묶을 때 사용하는

1. 함수 옮기기(8.1)
2. 필드 옮기기(8.2)

비슷한 데이터를 묶을 때 사용하는

3.  여러 함수를 클래스로 묶기(6.9)

데이터 구조를 변환하거나 보강할 때 사용하는

4. 여러 함수를 변환 함수로 묶기(6.10)

묶은 함수들의 출력 결과를 묶어서 다음 로직으로 전달할 때는

5. 단계 쪼개기(6.11)

어설프게 분리된 로직은

6. 함수 인라인하기(6.2)
7. 클래스 인라인하기(7.6)

### 1. 함수 옮기기(8.1)

함께 변경되는 대상들을 한 모듈로 묶을 때 사용합니다. 참고로 모듈성이란 프로그램의 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력입니다.

함수를 옮길지 말지 선택하기 전에 대상 함수를 호출하는 함수들은 무엇인지, 대상 함수가 호출하는 함수들은 무엇인지, 대상 함수가 사용하는 데이터는 무엇인지 살펴봐야 합니다.

리팩터링 전

- formatDate 함수는 Calendar 함수에서만 사용되는데 별도 모듈로 관리되고 있습니다.

```tsx
// src/utils/date.ts

export function formatDate(date: Date): string {
  return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
}
```

```tsx
// Calendar.svelte

<script lang="ts">
  import {formatDate} from '../utils/date'; let today = new Date(); let todayStr
  = formatDate(today);
</script>
```

리팩터링 후

- 실제 사용하는 컴포넌트 파일로 함수를 이동하여 모듈성을 향상시킵니다.

```tsx
<script lang="ts">
  function formatDate(date: Date): string {
    return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
  }

  let today = new Date();
  let todayStr = formatDate(today);
</script>
```

### 2. 필드 옮기기(8.2)

함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 할 때입니다. 함수에 함께 건네지는 데이터 조각들은 하나의 레코드에 담는 것이 좋습니다.

만약 한 레코드를 변경하려 할 때 다른 레코드의 필드까지 변경해야 한다면 필드 위치가 잘못되었을 수 있으니 위치를 옮기는 것을 고려해 보는 것이 좋습니다.

리팩터링 전

- 관련된 필드(folderIds, cameraIds)를 별도로 관리 및 전달되고 있었습니다.

```tsx
// UpdatePositionModal.svelte

const updateDirectory = async (
  event: CustomEvent<{ closeModal: () => void }>
) => {
  isLoading.set(true);
  const folderIds: number[] = [];
  const cameraIds: number[] = [];

  if (!selectedItems) return;

  selectedItems.forEach((item) => {
    if ("cameraId" in item) {
      cameraIds.push(item._id);
    } else {
      folderIds.push(item._id);
    }
  });

  const response = await moveFolder({
    parentId: selectedFolderToUpdate._id,
    folderIds,
    cameraIds,
  });
};
```

리팩터링 후

- target이라는 객체로 묶어서 전달합니다. 응집도가 높아지고 가독성과 유지보수성이 향상된다는 장점이 있습니다.

```tsx
const updateDirectory = async (
  event: CustomEvent<{ closeModal: () => void }>
) => {
  isLoading.set(true);

  if (!selectedItems) return;

  const target = {
    folderIds: [],
    cameraIds: [],
  };

  selectedItems.forEach((item) => {
    if ("cameraId" in item) {
      moveTarget.cameraIds.push(item._id);
    } else {
      moveTarget.folderIds.push(item._id);
    }
  });

  const response = await moveFolder({
    parentId: selectedFolderToUpdate._id,
    ...target,
  });
};
```

### 3. 여러 함수를 클래스로 묶기(6.9)

데이터와 함수를 하나의 공유 환경으로 묶은 후 그 중 일부를 외부에 제공할 수 있습니다. 그럼 공통 환경을 더 명확하게 표현할 수 있고 각 함수에 전달되는 인수를 줄여 객체 안에서의 함수 호출을 간결하게 만들 수 있습니다.

### 4. 여러 함수를 변환 함수로 묶기(6.10)

변환 함수는 원본 데이터를 입력 받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환합니다. 함수를 호출하여 리턴된 값을 변수에 할당한다고 생각하면 쉽습니다.

여러 함수를 변환 함수를 묶는 이유는 도출 로직이 중복되는 것을 피하기 위해서입니다.

리팩터링 전

- 리팩터링 전에는 좌표 변환 로직이 여러 곳에 흩어져 있었습니다.

```tsx
const transformCoordinates = (coordinates: Omit<AnchorType, "isFirst">[]) =>
  coordinates.map(({ _id, x, y, type }) => ({
    _id,
    x,
    y,
    isFirst: false,
    type,
  }));

const transformRatioCoordinate = (
  coordinate: AnchorType,
  savedStage: StageSizeType = {
    width: DEFAULT_STAGE_WIDTH,
    height: DEFAULT_STAGE_HEIGHT,
  }
) => {
  return {
    _id: coordinate._id,
    x: coordinate.x / savedStage.width,
    y: coordinate.y / savedStage.height,
    isFirst: coordinate.isFirst,
    type: coordinate.type,
  };
};
```

리팩터링 후

- 변환 함수를 별도 유틸로 분리하여 필요한 곳에서 호출할 수 있습니다.

```tsx
function toRoiStageStateData(roi: {
  polygonCoordinates: Omit<AnchorType, "isFirst">[];
  divideCoordinates: Omit<AnchorType, "isFirst">[][];
  size: StageSizeType;
}) {
  const polygonCoordinates = roi.polygonCoordinates.map(
    ({ _id, x, y, type }) => ({
      _id,
      x,
      y,
      isFirst: false,
      type,
    })
  );

  const divideLineCoordinates = roi.divideCoordinates.map((line) =>
    line.map(({ _id, x, y, type }) => ({
      _id,
      x,
      y,
      isFirst: false,
      type,
    }))
  );

  const polygonCoordinatesRatio = polygonCoordinates.map((anchor) => ({
    ...anchor,
    x: anchor.x / roi.size.width,
    y: anchor.y / roi.size.height,
  }));

  const divideLineCoordinatesRatio = divideLineCoordinates.map((anchorList) =>
    anchorList.map((anchor) => ({
      ...anchor,
      x: anchor.x / roi.size.width,
      y: anchor.y / roi.size.height,
    }))
  );

  return {
    polygonCoordinates,
    divideLineCoordinates,
    polygonCoordinatesRatio,
    divideLineCoordinatesRatio,
    isPolygon: polygonCoordinates.length > 2,
  };
}
```

```tsx
ROIStageState.update((prev) => {
  const roiData = toRoiStageStateData({
    polygonCoordinates,
    divideCoordinates,
    size,
  });
  return { ...prev, ...roiData };
});
```

### 5. 단계 쪼개기(6.11)

서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법입니다.

리팩터링 전

- 여러 단계가 하나의 함수에 섞여있습니다.
  - 선택된 항목 분류
  - 중복/이동 불가 체크
  - API 호출 및 후처리

```tsx
const updateDirectory = async (
  event: CustomEvent<{ closeModal: () => void }>
) => {
  isLoading.set(true);
  const folderIds: number[] = [];
  const cameraIds: number[] = [];

  if (!selectedItems) return;

  selectedItems.forEach((item) => {
    if ("cameraId" in item) {
      cameraIds.push(item._id);
    } else {
      folderIds.push(item._id);
    }
  });

  // 위치이동이 불가능한 경우
  if (
    folderIds.includes(selectedFolderToUpdate._id) ||
    selectedFolderToUpdate._id === Number($page.params.id)
  ) {
    isOpenDirectoryErrorModal = true;
  } else {
    const folders = await getFolders();
    if (!folders) return;

    const isDuplicate = checkDuplicateFolderName(folders as FolderDto[]);
    if (isDuplicate) {
      isOpenDuplicateErrorModal = !isOpenDuplicateErrorModal;
    } else {
      const response = await moveFolder({
        parentId: selectedFolderToUpdate._id,
        folderIds,
        cameraIds,
      });

      if (!response) return;

      if (response.status >= 400) {
        isOpenSubFolderErrorModal = true;
      } else {
        isOpenSubFolderErrorModal = false;
        dispatch("updateFolder");
        event.detail.closeModal();
      }
    }
    isOpenDirectoryErrorModal = false;
  }
};
```

리팩터링 후

- 각 단계를 별도 함수로 추출하여 코드의 책임과 가독성을 높였습니다.

```tsx
function splitSelectedItems(selectedItems) {
  const folderIds: number[] = [];
  const cameraIds: number[] = [];
  selectedItems.forEach((item) => {
    if ("cameraId" in item) {
      cameraIds.push(item._id);
    } else {
      folderIds.push(item._id);
    }
  });
  return { folderIds, cameraIds };
}

async function checkMovable(folderIds, selectedFolderToUpdate, $page) {
  return !(
    folderIds.includes(selectedFolderToUpdate._id) ||
    selectedFolderToUpdate._id === Number($page.params.id)
  );
}

async function handleMove(folderIds, cameraIds, selectedFolderToUpdate, event) {
  const response = await moveFolder({
    parentId: selectedFolderToUpdate._id,
    folderIds,
    cameraIds,
  });

  if (!response) return false;
  if (response.status >= 400) {
    isOpenSubFolderErrorModal = true;
    return false;
  } else {
    isOpenSubFolderErrorModal = false;
    dispatch("updateFolder");
    event.detail.closeModal();
    return true;
  }
}

const updateDirectory = async (
  event: CustomEvent<{ closeModal: () => void }>
) => {
  isLoading.set(true);
  if (!selectedItems) return;

  const { folderIds, cameraIds } = splitSelectedItems(selectedItems);

  if (!(await checkMovable(folderIds, selectedFolderToUpdate, $page))) {
    isOpenDirectoryErrorModal = true;
    return;
  }

  const folders = await getFolders();
  if (!folders) return;

  const isDuplicate = checkDuplicateFolderName(folders as FolderDto[]);
  if (isDuplicate) {
    isOpenDuplicateErrorModal = !isOpenDuplicateErrorModal;
    return;
  }

  await handleMove(folderIds, cameraIds, selectedFolderToUpdate, event);
  isOpenDirectoryErrorModal = false;
};
```

### 6. 함수 인라인하기(6.2)

### 7. 클래스 인라인하기(7.6)
