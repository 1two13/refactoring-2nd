# 3장 - 4. 긴 매개변수 목록

함수에 필요한 모든 것들을 모두 매개변수로 넘기게 되면 매개변수 목록이 길어지게 되고, 그 자체로 이해하기 어려운 때가 있습니다.

긴 매개변수 목록을 제거하기 위한 리팩터링 방법은 아래와 같습니다.

### 1. 매개변수를 질의 함수로 바꾸기 (11.5절)

다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 때 이러한 매개변수는 질의 함수로 바꿔 제거할 수 있습니다.

```jsx
function availableVacation(anEmployee, anEmployee.grade) {}
```

```jsx
function availableVacation(anEmployee) {
  const grade = anEmployee.grade;
}
```

매개변수 목록은 함수의 변동 요인을 모아놓은 곳입니다. 중복을 피할수록, 짧을수록 이해하기 쉽습니다.

여기서 말하는 중복이란, 피호출 함수가 스스로 쉽게 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복입니다.

매개변수를 질의 함수로 바꾸는 절차는 아래와 같습니다.

```jsx
get finalPrice() {
	const basePrice = this.quantity * this.itemPrice;
	let discountLevel;

	if(this.quantity > 100) discountLevel = 2;
	else discountLevel = 1;
	return this.discountedPrice(basePrice, discountLevel);
}

discountedPrice(basePrice, discountLevel) {
	switch(discountLevel) {
		case1: return basePrice * 0.95);
		case2: return basePrice * 0.9);
}
```

1.필요하다면 대상 매개변수의 값을 계산하는 코드를 별도 함수로 추출합니다.

```jsx
get finalPrice() {
	const basePrice = this.quantity * this.itemPrice;
	return this.discountedPrice(basePrice, discountLevel);
}

get discountLevel() {
	return (this.quantity > 100) ? 2 : 1;
}
```

2.함수 본문에서 대상 매개변수로의 참조를 모두 찾아서 그 매개변수의 값을 만들어주는 표현식을 참조하도록 바꿉니다.

```jsx
discountedPrice(basePrice, discountLevel) {
	switch(this.discountLevel) {
		case1: return basePrice * 0.95);
		case2: return basePrice * 0.9);
}
```

3.하나 수정할 때마다 테스트합니다.

4.함수 선언 바꾸기로 대상 매개변수를 없앱니다.

```jsx
get finalPrice() {
	const basePrice = this.quantity * this.itemPrice;
	return this.discountedPrice(basePrice);
}

discountedPrice(basePrice) {
	switch(this.discountLevel) {
		case1: return basePrice * 0.95);
		case2: return basePrice * 0.9);
}
```

참고로 매개변수를 질의 함수로 바꾸지 말아야 하는 상황도 존재합니다. 매개변수를 제거했을 때 피호출 함수에 원치 않는 의존성이 생길 때입니다.

```jsx
// 전역 상태 또는 외부 상태에 의존하게 됨
const user = { role: "admin" };

function canDeletePost() {
  return user.role === "admin"; // 외부 상태(user)에 의존
}

function deletePost() {
  if (canDeletePost()) {
    console.log("게시글 삭제됨");
  } else {
    console.log("삭제 권한 없음");
  }
}
```

예를 들어 위의 코드에서 deletePost 함수는 암묵적으로 user라는 외부 상태에 의존하고 있게 됩니다. 이 경우에 테스트도 어렵고, 재사용성도 떨어지며, 유지보수하기 어렵습니다.

### 2. 객체 통째로 넘기기 (11.4절)

사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 객체를 통째로 넘겨 원본 데이터 구조를 그대로 전달할 수 있습니다.

객체 통째로 넘기면 변화에 대응하기 쉽습니다. 더 다양한 데이터를 사용하도록 바뀌어도 매개변수 목록을 수정할 필요가 없기 때문입니다. 그리고 로직 중복도 없앨 수 있습니다.

객체 통째로 넘기는 절차는 아래와 같습니다.

```jsx
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;

if(aPlan.withinRange(low, high)) {
	alert.push('방 온도가 지정 범위를 벗어났습니다.');
}

withinRange(bottom, top) {
	return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high);
}
```

1.매개변수들을 원하는 형태로 받는 빈 함수를 만듭니다. 찾아 바꾸기 쉽게 적당한 접두어를 붙입니다.

```jsx
xxNEWwithinRange(aNumberRange) {}
```

2.새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑합니다.

```jsx
xxNEWwithinRange(aNumberRange) {
	return this.withinRange(aNumberRange.low, aNumberRange.high);
}
```

3.정적 검사를 수행합니다.

4.모든 호출자가 새 함수를 사용하게 수정합니다. 기존 코드 중 필요 없는 부분은 제거합니다.

```jsx
~~const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;~~

if(!aPlan.xxNEWwithinRange(aRoom.daysTempRange)) {
	alert.push('방 온도가 지정 범위를 벗어났습니다.');
}
```

5.하나씩 수정하며 테스트합니다.

6.호출자를 모두 수정했다면 원래 함수를 인라인합니다.

```jsx
xxNEWwithinRange(aNumberRange) {
	return (aNumberRange.low >= this._temperatureRange.low) && (aNumberRange.high <= this._temperatureRange.high);
}
```

7.새 함수의 이름을 적절히 수정하고 모든 호출자에 반영합니다.

```jsx
withinRange(aNumberRange) {
	return (aNumberRange.low >= this._temperatureRange.low) && (aNumberRange.high <= this._temperatureRange.high);
}

if(!aPlan.withinRange(aRoom.daysTempRange)) {
	alert.push('방 온도가 지정 범위를 벗어났습니다.');
}
```

### 3. 매개변수 객체 만들기 (6.8절)

항상 함께 전달되는 매개변수는 객체로 하나로 묶어버리면 됩니다.

```jsx
function amountInvoiced(startDate, endDate) {}
```

```jsx
function amountInvoiced(aDateRange) {}
```

데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해지고, 매개변수 수가 줄어든다는 장점이 있습니다. 또한 같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 똑같은 이름을 사용하기 때문에 일관성도 높여줍니다.

매개변수를 객체로 만드는 절차는 아래와 같습니다.

```jsx
const station = {
  name: "ZB1",
  readings: [
    { temp: 47, time: "2025-08-6 22:25" },
    { temp: 47, time: "2025-08-6 22:26" },
  ],
};

function readingsOutsideRange(station, min, max) {
  return station.readings.filter((r) => r.temp < min || r.temp > max);
}

alerts = readingsOutsideRange(
  station,
  operatingPlan.temperatureFloor,
  operatingPlan.temperatureCeiling
);
```

1.적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만듭니다.

```jsx
class NumberRange {
  constructor(min, max) {
    this._data = { min: min, max: max };
  }
  get min() {
    return this._data.min;
  }
  get max() {
    return this._data.max;
  }
}
```

2.함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가합니다.

```jsx
function readingsOutsideRange(station, min, max, range) {
  return station.readings.filter((r) => r.temp < min || r.temp > max);
}

alerts = readingsOutsideRange(
  station,
  operatingPlan.temperatureFloor,
  operatingPlan.temperatureCeiling
);
```

3.함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정합니다.

```jsx
const range = new NumberRange(
  operatingPlan.temperatureFloor,
  operatingPlan.temperatureCeiling
);

alerts = readingsOutsideRange(
  station,
  operatingPlan.temperatureFloor,
  operatingPlan.temperatureCeiling,
  range
);
```

4.하니씩 수정할 때마다 테스트합니다.

5.기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꿉니다.

```jsx
function readingsOutsideRange(station, range) {
  return station.readings.filter(
    (r) => r.temp < range.min || r.temp > range.max
  );
}

const range = new NumberRange(
  operatingPlan.temperatureFloor,
  operatingPlan.temperatureCeiling
);

alerts = readingsOutsideRange(station, range);
```

1. 다 바꿨다면 기존 매개변수를 제거하고 테스트합니다.

### 4. 플래그 인수 제거하기 (11.3절)

함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거를 통해 없앨 수 있습니다. 플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수입니다.

```jsx
function setDimension(name, value) {
  if (name === "height") {
    this._height = value;
    return;
  }

  if (name === "width") {
    this.width = value;
    return;
  }
}
```

```jsx
function setHeight(value) {
  this._height = value;
}

function setWidth(value) {
  this.width = value;
}
```

플래그 인수를 제거해야 하는 이유는 호출할 수 있는 함수가 무엇이고 어떻게 호출해야 하는지 이해하기 어려워지기 때문입니다.

함수 하나에서 플래그 인수를 두 개 이상 사용하면 플래그 인수를 써야 하는 합당한 근거가 될 수 있지만 둘 이상이면 함수 하나가 너무 많은 일을 처리하고 있지는 않은지 더 간단한 함수를 만들 방법을 고민해봐야 합니다.

플래그 인수를 제거하는 절차는 아래와 같습니다.

```jsx
aShipment.deliveryDate = deliveryDate(anOrder, true);
aShipment.deliveryDate = deliveryDate(anOrder, false);
```

1. 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적 함수들을 생성합니다.

```jsx
function deliveryDate(anOrder, isRush) {
  if (isRush) return rushDeliveryDate(anOrder);
  else return regularDeliveryDate(anOrder);
}
```

1. 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정합니다.

```jsx
aShipment.deliveryDate = deliveryDate(anOrder, true);
aShipment.deliveryDate = deliveryDate(anOrder);
```

### 5. 여러 함수를 클래스로 묶기 (6.9절)

여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 여러 함수를 클래스로 묶어 공통 값들을 클래스의 필드로 정의할 수 있습니다.

```jsx
function base(aReading) {}
function taxableCharge(aReading) {}
function calculateBaseCharge(aReading) {}
```

```jsx
class Reading {
  base() {}
  taxableCharge() {}
  calculateBaseCharge() {}
}
```

클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공합니다.

클래스로 묶으면 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여 객체 안에서의 함수 호출을 간결하게 만들 수 있습니다. 또한 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다는 장점이 있습니다.

여러 함수를 클래스로 묶는 절차는 아래와 같습니다.

1.함수들이 공유하는 공통 데이터 레코드를 캡슐화합니다.

```jsx
const post = {
  title: "리팩터링 가이드",
  content: "클래스로 묶는 법을 배우자",
  likes: 10,
};

function getSummary() {
  return post.title + " - " + post.content.slice(0, 10) + "...";
}

function likePost() {
  post.likes += 1;
}

function printLikes() {
  console.log(`Likes: ${post.likes}`);
}
```

2.공통 레코드를 사용하는 함수 각각을 새 클래스로 옮깁니다.

```jsx
class Post {
  constructor(data) {
    this.title = data.title;
    this.content = data.content;
    this.likes = data.likes;
  }

  getSummary() {
    return this.title + " - " + this.content.slice(0, 10) + "...";
  }

  likePost() {
    this.likes += 1;
    if (this.likes >= 100) {
      return "인기 게시물 입니다.";
    }
  }

  printLikes() {
    console.log(`Likes: ${this.likes}`);
  }
}
```

3.데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮깁니다.

```jsx
class Post {
  constructor(data) {
    this.title = data.title;
    this.content = data.content;
    this.likes = data.likes;
  }

  getSummary() {
    return this.title + " - " + this.content.slice(0, 10) + "...";
  }

  likePost() {
    this.likes += 1;
    this.popular();
  }

  printLikes() {
    console.log(`Likes: ${this.likes}`);
  }

  isPopular(likes) {
    return this.likes >= 100;
  }
}
```
