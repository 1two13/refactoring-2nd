# 3장 - 12. 반복되는 switch문

반복되는 switch문은 다형성으로 바꿔야합니다.

그 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문입니다.

여기서 말하는 다형성은 객체 지향 프로그래밍의 특징 중 하나로 하나의 객체가 여러 형태를 가질 수 있는 성질입니다. 즉, 같은 이름을 가진 메서드나 객체가 상황에 따라 다르게 동작할 수 있음을 의미합니다.

### 1. 조건부 로직을 다형성으로 바꾸기(10.4절)

새의 종에 따른 비행 속도와 깃털 상태를 아는 프로그램을 리팩터링 해보겠습니다.

**리팩터링 전**

- 새 종류(bird.type)가 지금은 2가지 종류이지만 늘어날 때마다 각 함수에 대해 switch문은 또 추가되며 가독성은 안 좋아진다.

```jsx
// 새의 깃털
function plumages(birds) {
  return new Map(birds.map((b) => [b.name, plumage(b)]));
}

// 새의 속도
function speeds(birds) {
  return new Map(birds.map((b) => [b.name, airSpeedVelocity(b)]));
}

function plumage(bird) {
  switch (bird.type) {
    case "유럽 제비":
      return "보통이다";
    case "아프리카 제비":
      return bird.numberofCoconuts > 2 ? "지쳤다" : "보통이다";
    default:
      return "알 수 없다";
  }
}

function airSpeedVelocity(bird) {
  switch (bird.type) {
    case "유럽 제비":
      return 35;
    case "아프리카 제비":
      return 40 - 2 * bird.numberOfCoconuts;
    default:
      return null;
  }
}

// 실행
plumages(["유럽 제비", "아프리카 제비"]);
speeds(["유럽 제비", "아프리카 제비"]);
```

**리팩터링 후**

- plumage와 airSpeedVelocity를 새로운 Bird라는 클래스로 묶습니다.
- 종별 서브 클래스를 만듬으로써 하나의 Bird라는 객체가 여러 형태(유럽 제비, 아프리카 제비) 등의 형태를 가지며 다르게 동작할 수 있습니다.
- 슈퍼클래스 메서드에는 기본 동작 부분만 남깁니다.
- 서브 클래스가 슈퍼클래스의 조건부 로직 메서드를 오버라이드하도록 합니다.

```jsx
function plumages(birds) {
  return new Map(birds.map(b => createBird(b)).map(bird => [bird.name, bird.plumage]))
}

function speeds(birds) {
  return new Map(birds.map(b => createBird(b)).map(bird => [bird.name, bird.airSpeedVelocity]))
}

function createBird(bird) {
  switch(bird.type) {
    case '유럽 제비':
      return new EuropeanSwallow(bird);
    case '아프리카 제비':
      return nre AfricanSwallow(bird);
  }
}

// 슈퍼클래스 메서드
class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }
  get plumage() {
    return '알 수 없다';
  }
  get airSpeedVelocity() {
    return null;
  }
}

class EuropeanSwallow extend Bird {
  get plumage() {
    return '보통이다';
  }
  get airSpeedVelocity() {
    return 35;
  }
}
```

또 다른 예로 거의 똑같은 객체이지만 다른 부분도 있음을 표현할 때도 상속을 사용합니다.

**리팩터링 전**

- 타입별로 유사하지만 다른 로직이 섞여있습니다.
- 새로운 타입 추가 시 switch를 수정해야합니다.

```jsx
class Bird {
  getSpeed() {
    switch (type) {
      case EUROPEAN:
        return getBaseSpeed();
      case AFRICAN:
        return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;
      case NORWEGIAN_BLUE:
        return isNailed ? 0 : getBaseSpeed(voltage);
    }
    throw new RuntimeException("Should be unreachable");
  }
}
```

**리팩터링 후**

- 타입에 따라 분기하던 코드를 각각의 하위 클래스 구현으로 분리합니다.
- 타입 추가 시 기존 코드 수정 없이 새로운 하위 클래스 추가만으로 확장이 가능합니다.

```jsx
class Bird {
  getSpeed();
}

class European extends Bird {
  getSpeed() {
    return getBaseSpeed();
  }
}

class African extends Bird {
  getSpeed() {
    return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;
  }
}

class NorwegianBlue extends Bird {
  getSpeed() {
    return isNailed ? 0 : getBaseSpeed(voltage);
  }
}

// 호출부는 이제 타입에 상관없이 이렇게 사용 가능
const bird = new Bird();
bird.getSpeed();
```

이러한 리팩터링을 통해 가질 수 있는 장점은 아래와 같습니다.

1. switch문이나 if-else 사용 ⇒ 상속받은 클래스에 메서드 호출
2. 새로운 타입 추가 시 switch 수정 필요 ⇒ 클래스 추가만으로 확장 가능
3. 조건부 로직이 여러 곳에 흩어질 수 있음 ⇒ 각 하위 클래스에 책임 캡슐화
4. 분기 로직 복잡하여 변경 시 오류 위험 ⇒ 각각 책임이 명확히 분리됨
