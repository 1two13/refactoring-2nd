# 1장. 리팩터링: 첫 번째 예시

수백 줄짜리 코드를 수정한다고 가정해 봅시다. 무작정 달려드려 막 바꾸기 보다는 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성하는 것이 좋습니다.

만약 구조가 빈약하다면 구조부터 바로 잡은 후에 기능을 수정하는 것이 좋습니다.

리팩터링을 어떤 단계로 진행하면 될지 설명해보도록 하겠습니다. 미리 말하겠지만 매 단계가 끝날 때마다 컴파일 ⇒ 테스트⇒ 커밋 과정을 계속 반복하여 피드백 주기를 짧게 가져가야 합니다.

1. 먼저 테스트를 마련해야 합니다. 테스트는 거창한 것이 아닌 자가진단이 가능하도록 만들면 됩니다.
   - 원하는 내용을 소스 코드와 테스트 코드 양쪽에 적어두면 중복 검사를 통해 실수 가능성을 줄일 수 있습니다.
   - 테스트를 작성하는 데 시간이 소요되지만 디버깅 시간이 줄어 전체 작업 시간은 오히려 단축됩니다.
   - 하지만 우리 회사 특성 상 리팩터링할 시간이 주어지는 환경이 아닌 빠르게 핵심 기능을 구현해야하는 상황이므로 과연 테스트 코드 작성까지 가능할지는 잘 모르겠습니다..
2. 함수를 추출해야 합니다.
   - 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾고, 함수로 쪼개어 추출해야합니다.
   - 별도 함수로 분리했을 때, 새로운 함수에서 곧바로 사용할 수 없는 변수가 있는지 확인합니다.
   - 그러한 변수가 있다면 매개변수로 전달하거나 값을 반환하도록 해주세요.
     - 참고로 매개변수의 역할이 뚜렷하지 않을 때는 부정관사(a/an)을 붙이고,
     - 함수의 반환 값은 result라는 이용을 사용해주세요.
3. 변수를 인라인해야 합니다.
   - 불필요한 변수는 인라인하여 사용하고 따로 변수로 선언하지 않는 방식입니다.
   - 저는 주로 변수를 따로 선언하고, 선언된 변수를 사용하는 것이 가독성에 더 좋다고 판단하였는데, 이 책에서는 그렇지 않았던 것 같습니다. 다른 분들의 의견도 궁금합니다.
4. 계산 단계와 포맷팅 단계를 분리합니다.
5. 반복문을 쪼갭니다.
   - 변수 값을 누적시키는 부분은 분리합니다.
6. 반복문을 파이프라인으로 바꿉니다.
   - for 반복문이 아닌 파이프라인으로 바꿉니다. ex. reduce
7. 문장을 슬라이스합니다.
   - 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮기는 방식입니다.
8. 다형성을 활용하여 계산 코드를 재구성합니다.
   - 조건부 로직을 상속 계층을 구성하여 로직을 정의합니다.
   - 클래스를 사용합니다.

때로는 리팩터링이 성능에 영향을 주기도 합니다. 그래서 사실 리팩터링을 하기 두려운 경우도 생기는 것 같습니다. 하지만 그러한 경우에도 개의치 않고 리팩터링을 하는 것을 추천하고 있습니다. 잘 다듬어진 코드여야 성능 개선 작업도 훨씬 수월하고, 성능이 만약에 떨어졌다면 리팩터링 후 시간을 내어 성능을 개선하는 것이 더 낫다고 언급하고 있습니다.

정리하자면, 리팩터링은 크게 3단계로 진행하면 됩니다.

1. 원본 함수를 중첩 함수 여러개로 나누고
2. 계산 코드와 출력 코드를 분리하고
3. 계산 로직을 다형성으로 표현합니다.

리팩터링의 목표는 코드 구조 보강과 코드가 수행하는 일을 명확하게 드러내는 일이라고 생각합니다. 추후에 코드를 바라보았을 때 얼마나 수정하기 쉬운가에 초점을 두고 리팩터링을 하면 좋을 것 같습니다.
