# 2장. 리팩터링 원칙

### 리팩터링 정의

리팩터링이란 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법입니다.

**리팩터링을 할 때 항상 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있어야 합니다.** 코드가 항상 정상 작동하기 때문입니다.

**리팩터링을 하는 과정에서 발견된 버그는 리팩터링 후에도 남아 있어야 합니다.** 버그와 리팩터링을 같이 가져가려고 하면 안됩니다! 기능 추가도 마찬가지 입니다. 기능 추가 시 기존 코드는 건드리지 않고 새 기능을 추가하기만 해야 하고, 리팩터링 시에는 기능 추가는 절대 하지 않고 코드 재구성에만 집중해야 합니다.

### 리팩터링하는 이유

1. 소프트웨어 설계가 좋아지기 때문입니다.

   중복 코드 제거를 통해 시스템이 빨라지는 것은 아니지만 수정하는 데 드는 노력이 적어지고, 이해해야 할 코드량도 줄어듭니다. 또한 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있습니다.

2. 소프트웨어를 이해하기 쉬워지기 때문입니다.
3. 버그를 쉽게 찾을 수 있기 때문입니다.

   리팩터링을 하는 과정에서 코드가 하는 일을 깊이 파악할 수 있기 때문입니다.

4. 프로그래밍 속도를 높일 수 있기 때문입니다.

   좋은 설계의 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있습니다.

   - 모듈화가 잘 되어 있으면 전체 코드 베이스 중 작은 일부만 이해하면 되고,
   - 코드가 명확하면 버그 가능성이 줄고,
   - 버그를 만들더라도 디버깅하기 쉽습니다.
   - 그리고 새 기능 구축을 돕는 견고한 토대가 됩니다. 기존의 설계를 지속해서 개선할 수 있기 때문입니다.

### 리팩터링 시점

1. 준비를 위한, 즉 기능을 쉽게 추가하게 만들기 위한 리팩터링

   리팩터링하기 가장 좋은 시점은 새로운 기능을 추가하기 직전입니다. 구조를 살짝 바꿨을 때 다른 작업을 하기가 쉬워질 만한 부분을 찾아 리팩터링합니다.

   예를 들어, 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있을 때 함수 매개변수화하기를 적용하여 리팩터링 하고, 호출할 때는 함수에 필요한 매개변수만 지정하여 호출할 수 있습니다.

   또 다른 예로, 오류를 일으키는 코드가 복제되어 퍼져있다면 한 곳으로 합치는 것이 작업하기에 용이합니다.

   마지막 예로 질의 코드에 섞여 잇는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 줄일 수 있습니다.

2. 코드를 이해하기 쉽게 만들기 위한 리팩터링

   코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지가 없는지 확인합니다.

3. 쓰레기 줍기 리팩터링

   말그대로 쓰레기가 나중에 일을 방해하도록 내버려두는 것은 좋지 않습니다. 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 하던 일을 끝내고 나서 처리하는 것이 좋습니다.

4. 계획된 리팩터링과 수시로 하는 리팩터링

   1 ~ 3번에서 설명한 리팩터링 시점은 모두 기회가 될 때만 진행합니다. 즉 계획된 리팩터링입니다.

   수시로 하는 리팩터링은 일정을 따로 잡아두지 않고 기능을 추가하거나 버그를 잡는 동안 함께 하는 리팩터링입니다.

   계획된 리팩터링을 하게 되는 일은 최소한으로 줄이고, 리팩터링 작업 대부분은 기회가 될 때마다 해야 합니다.

5. 시간이 오래 걸리는 리팩터링

   예를 들어 라이브러리를 교체할 때 기존 것과 새 것 모두 포용하는 추상 인터페이스를 마련하고, 기존 코드가 추상 인터페이스를 호출하도록 만듭니다. 그러고 나면 라이브러리를 훨씬 쉽게 교체할 수 있습니다.

6. 코드 리뷰

   리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데 도움이 됩니다. 개선안들을 제시하는 데서 그치지 않고, 즉시 구현해볼 수 있기 때문입니다.

### 관리자에게 리팩터링을 어떻게 말할까?

개발자가에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이기 때문에 리팩터링이 필요합니다 라고 말합시다.

리팩터링은 경제적인 이유로 하는 것입니다. 기능 추가 시간과 버그 수정 시간을 줄여주기 때문입니다.

### 리팩터링하지 말아야 할 때

1. 지저분한 코드를 발견해도 굳이 수정할 필요가 없을 때

   예를 들어, 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 유지합니다.

2. 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때

### 리팩터링 시 고려할 문제

1. 새 기능 개발 속도 저하

   새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이 있다면 리팩터링부터 합니다.

2. 코드 소유권과 브랜치 전략
3. 테스팅

   시간을 들여서라도 자가 테스트 코드를 마련해야 합니다.

4. 레거시 코드

   자주 보는 코드를 더 많이 리팩터링해야 합니다.

5. 데이터베이스

   데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다릅니다.

   예를 들어 필드 이름을 바꿀 때

   1. 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지 않습니다. 그 다음 기존 필드와 새 필드를 동시에 업데이트하도록 설정합니다.
   2. 그 다음 데이터베이스를 읽는 클라이언트를 새 필드를 사용하는 버전으로 교체합니다.
   3. 이 과정에서 발생하는 버그를 해결합니다.
   4. 클라이언트 교체 작업을 모두 끝냈다면 더는 필요가 없어진 예전 필드를 삭제합니다.

### 리팩터링, 아키텍처, 애그니(You aren’t going to neeed it)

리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 점입니다.

모든 상황을 고려하다보면 유연성 메커니즘이 오히려 변화에 대응하는 능력을 떨어트릴 수 있기 때문에 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축하는 것이 좋습니다.

단, 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만, 복잡도를 높일 수 있는 메커니즘은 반드시 검증을 거친 후에 추가해야 합니다.

### 리팩터링과 성능

시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 합니다. 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당하여 시간과 공간을 많이 잡아먹는 지점을 알아내야 합니다.

리팩터링을 하면 최적화 측면에서 2가지 장점이 있습니다. 첫 번째는 성능 튜닝에 투입할 시간을 벌 수 있다는 것이고, 두 번째는 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다는 것입니다.
